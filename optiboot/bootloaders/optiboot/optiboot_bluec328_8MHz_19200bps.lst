
optiboot_bluec328_8MHz_19200bps.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001fc  00007e00  00007e00  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .debug_aranges 00000028  00000000  00000000  00000250  2**0
                  CONTENTS, READONLY, DEBUGGING
  2 .debug_pubnames 0000009e  00000000  00000000  00000278  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   0000027d  00000000  00000000  00000316  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 00000185  00000000  00000000  00000593  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   00000481  00000000  00000000  00000718  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_frame  00000080  00000000  00000000  00000b9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    00000177  00000000  00000000  00000c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000022e  00000000  00000000  00000d93  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00000060  00000000  00000000  00000fc1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007e00 <main>:
register uint8_t timOverflCnt __asm__("r15"); // the number of timer1 overflows
#endif


/* main program starts here */
int main(void) {
    7e00:	11 24       	eor	r1, r1
#endif

  uint8_t ch;

  // Adaboot no-wait mod
  ch = MCUSR;
    7e02:	14 b7       	in	r17, 0x34	; 52
  MCUSR = 0;
    7e04:	14 be       	out	0x34, r1	; 52
  //if (!(ch & _BV(EXTRF))) appStart();

  // Set up watchdog to trigger after 500ms
  watchdogConfig(WATCHDOG_1S);
    7e06:	8e e0       	ldi	r24, 0x0E	; 14
    7e08:	dc d0       	rcall	.+440    	; 0x7fc2 <watchdogConfig>

#if (LED_START_FLASHES > 0) || defined(BLUECONTROLLER)
  // Set up Timer 1 for timeout counter
  TCCR1B = _BV(CS12) | _BV(CS10); // div 1024
    7e0a:	85 e0       	ldi	r24, 0x05	; 5
    7e0c:	80 93 81 00 	sts	0x0081, r24
  UCSRA = _BV(U2X); //Double speed mode USART
  UCSRB = _BV(RXEN) | _BV(TXEN);  // enable Rx & Tx
  UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);  // config USART; 8N1
  UBRRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
#else
  UCSR0A = _BV(U2X0); //Double speed mode USART0
    7e10:	82 e0       	ldi	r24, 0x02	; 2
    7e12:	80 93 c0 00 	sts	0x00C0, r24
  UCSR0B = _BV(RXEN0) | _BV(TXEN0);
    7e16:	88 e1       	ldi	r24, 0x18	; 24
    7e18:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
    7e1c:	86 e0       	ldi	r24, 0x06	; 6
    7e1e:	80 93 c2 00 	sts	0x00C2, r24
  UBRR0L = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
    7e22:	83 e3       	ldi	r24, 0x33	; 51
    7e24:	80 93 c4 00 	sts	0x00C4, r24
#endif
#endif

#if defined(BLUECONTROLLER) 
  BLUEC_BTN_PORT |= _BV(BLUEC_BTN); // enable pull-up for BlueController button 
    7e28:	5a 9a       	sbi	0x0b, 2	; 11
  //BLUEC_BT_RESET_PORT |= _BV(BLUEC_BT_RESET); // set BlueController BTM-222 RESET line to HIGH/pullup-enable
  //BLUEC_BT_RESET_DDR |= _BV(BLUEC_BT_RESET); /* set BlueController BTM-222 RESET line as output */
  blueCAvrdudeSynced = 0;
    7e2a:	dd 24       	eor	r13, r13
  timOverflCnt = 0;
    7e2c:	ff 24       	eor	r15, r15
  blueCBtnNotPressed = (BLUEC_BTN_PIN & _BV(BLUEC_BTN));
    7e2e:	89 b1       	in	r24, 0x09	; 9
    7e30:	04 e0       	ldi	r16, 0x04	; 4
    7e32:	e0 2e       	mov	r14, r16
    7e34:	e8 22       	and	r14, r24

  if(enterBootloaderByAppMagic == ENTER_BL_MAGIC)
    7e36:	80 91 00 01 	lds	r24, 0x0100
    7e3a:	90 91 01 01 	lds	r25, 0x0101
    7e3e:	8e 59       	subi	r24, 0x9E	; 158
    7e40:	94 4c       	sbci	r25, 0xC4	; 196
    7e42:	21 f4       	brne	.+8      	; 0x7e4c <main+0x4c>
  {
    enterBootloaderByAppMagicLSB = 0; // disable magic mechanism for next reset to avoid endless loop
    7e44:	10 92 00 01 	sts	0x0100, r1
    blueCBtnNotPressed = 0;
    7e48:	ee 24       	eor	r14, r14
    7e4a:	02 c0       	rjmp	.+4      	; 0x7e50 <main+0x50>
  }
  else
  {
    if (!(ch & _BV(EXTRF)))
    7e4c:	11 ff       	sbrs	r17, 1
      appStart();
    7e4e:	bf d0       	rcall	.+382    	; 0x7fce <appStart>

#if defined(BLUECONTROLLER) 
    if(ch == STK_GET_SYNC) {
      // this is the initial sequence, sent by avrdude
      verifySpace();
      blueCAvrdudeSynced = 1;
    7e50:	66 24       	eor	r6, r6
    7e52:	63 94       	inc	r6
        __boot_page_fill_short((uint16_t)(void*)addrPtr,a);
        addrPtr += 2;
      } while (--ch);
      
      // Write from programming buffer
      __boot_page_write_short((uint16_t)(void*)address);
    7e54:	15 e0       	ldi	r17, 0x05	; 5
    7e56:	51 2e       	mov	r5, r17
      boot_spm_busy_wait();

#if defined(RWWSRE)
      // Reenable read access to flash
      boot_rww_enable();
    7e58:	b1 e1       	ldi	r27, 0x11	; 17
    7e5a:	7b 2e       	mov	r7, r27
      // If we are in NRWW section, page erase has to be delayed until now.
      // Todo: Take RAMPZ into account
#if !defined(NRWWSECTIONFAVORSIZE) 
      if (!((uint8_t)(address >> 8) < (uint8_t)(NRWWSTART >> 8)))
#endif
        __boot_page_erase_short((uint16_t)(void*)address);
    7e5c:	a3 e0       	ldi	r26, 0x03	; 3
    7e5e:	8a 2e       	mov	r8, r26
#endif

  /* Forever loop */
  for (;;) {
    /* get character from UART */
    ch = getch();
    7e60:	9a d0       	rcall	.+308    	; 0x7f96 <getch>

#if defined(BLUECONTROLLER) 
    if(ch == STK_GET_SYNC) {
    7e62:	80 33       	cpi	r24, 0x30	; 48
    7e64:	21 f4       	brne	.+8      	; 0x7e6e <main+0x6e>
      // this is the initial sequence, sent by avrdude
      verifySpace();
    7e66:	ba d0       	rcall	.+372    	; 0x7fdc <verifySpace>
      blueCAvrdudeSynced = 1;
    7e68:	dd 24       	eor	r13, r13
    7e6a:	d3 94       	inc	r13
    7e6c:	89 c0       	rjmp	.+274    	; 0x7f80 <main+0x180>
    }
    else 
#endif
    if(ch == STK_GET_PARAMETER) {
    7e6e:	81 34       	cpi	r24, 0x41	; 65
    7e70:	21 f4       	brne	.+8      	; 0x7e7a <main+0x7a>
      // GET PARAMETER returns a generic 0x03 reply - enough to keep Avrdude happy
      getNch(1);
    7e72:	81 e0       	ldi	r24, 0x01	; 1
    7e74:	bb d0       	rcall	.+374    	; 0x7fec <getNch>
      putch(0x03);
    7e76:	83 e0       	ldi	r24, 0x03	; 3
    7e78:	1c c0       	rjmp	.+56     	; 0x7eb2 <main+0xb2>
    }
    else if(ch == STK_SET_DEVICE) {
    7e7a:	82 34       	cpi	r24, 0x42	; 66
    7e7c:	11 f4       	brne	.+4      	; 0x7e82 <main+0x82>
      // SET DEVICE is ignored
      getNch(20);
    7e7e:	84 e1       	ldi	r24, 0x14	; 20
    7e80:	03 c0       	rjmp	.+6      	; 0x7e88 <main+0x88>
    }
    else if(ch == STK_SET_DEVICE_EXT) {
    7e82:	85 34       	cpi	r24, 0x45	; 69
    7e84:	19 f4       	brne	.+6      	; 0x7e8c <main+0x8c>
      // SET DEVICE EXT is ignored
      getNch(5);
    7e86:	85 e0       	ldi	r24, 0x05	; 5
    7e88:	b1 d0       	rcall	.+354    	; 0x7fec <getNch>
    7e8a:	7a c0       	rjmp	.+244    	; 0x7f80 <main+0x180>
    }
    else if(ch == STK_LOAD_ADDRESS) {
    7e8c:	85 35       	cpi	r24, 0x55	; 85
    7e8e:	61 f4       	brne	.+24     	; 0x7ea8 <main+0xa8>
      // LOAD ADDRESS
      address = getch();
    7e90:	82 d0       	rcall	.+260    	; 0x7f96 <getch>
      address = (address & 0xff) | (getch() << 8);
    7e92:	08 2f       	mov	r16, r24
    7e94:	10 e0       	ldi	r17, 0x00	; 0
    7e96:	7f d0       	rcall	.+254    	; 0x7f96 <getch>
    7e98:	90 e0       	ldi	r25, 0x00	; 0
    7e9a:	b8 2e       	mov	r11, r24
    7e9c:	aa 24       	eor	r10, r10
    7e9e:	a0 2a       	or	r10, r16
    7ea0:	b1 2a       	or	r11, r17
#ifdef RAMPZ
      // Transfer top bit to RAMPZ
      RAMPZ = (address & 0x8000) ? 1 : 0;
#endif
      address += address; // Convert from word address to byte address
    7ea2:	aa 0c       	add	r10, r10
    7ea4:	bb 1c       	adc	r11, r11
    7ea6:	6b c0       	rjmp	.+214    	; 0x7f7e <main+0x17e>
      verifySpace();
    }
    else if(ch == STK_UNIVERSAL) {
    7ea8:	86 35       	cpi	r24, 0x56	; 86
    7eaa:	29 f4       	brne	.+10     	; 0x7eb6 <main+0xb6>
      // UNIVERSAL command is ignored
      getNch(4);
    7eac:	84 e0       	ldi	r24, 0x04	; 4
    7eae:	9e d0       	rcall	.+316    	; 0x7fec <getNch>
      putch(0x00);
    7eb0:	80 e0       	ldi	r24, 0x00	; 0
    7eb2:	69 d0       	rcall	.+210    	; 0x7f86 <putch>
    7eb4:	65 c0       	rjmp	.+202    	; 0x7f80 <main+0x180>
    }
    /* Write memory, length is big endian and is in bytes */
    else if(ch == STK_PROG_PAGE) {
    7eb6:	84 36       	cpi	r24, 0x64	; 100
    7eb8:	09 f0       	breq	.+2      	; 0x7ebc <main+0xbc>
    7eba:	3c c0       	rjmp	.+120    	; 0x7f34 <main+0x134>
      // PROGRAM PAGE - we support flash programming only, not EEPROM
      uint8_t *bufPtr;
      uint16_t addrPtr;

      getch();			/* getlen() */
    7ebc:	6c d0       	rcall	.+216    	; 0x7f96 <getch>
      length = getch();
    7ebe:	6b d0       	rcall	.+214    	; 0x7f96 <getch>
    7ec0:	08 2f       	mov	r16, r24
      getch();
    7ec2:	69 d0       	rcall	.+210    	; 0x7f96 <getch>

      // If we are in RWW section, immediately start page erase
#if !defined(NRWWSECTIONFAVORSIZE) 
      if ((uint8_t)(address >> 8) < (uint8_t)(NRWWSTART >> 8))
    7ec4:	8b 2d       	mov	r24, r11
    7ec6:	99 27       	eor	r25, r25
    7ec8:	18 2f       	mov	r17, r24
    7eca:	80 37       	cpi	r24, 0x70	; 112
    7ecc:	18 f4       	brcc	.+6      	; 0x7ed4 <main+0xd4>
        __boot_page_erase_short((uint16_t)(void*)address);
    7ece:	f5 01       	movw	r30, r10
    7ed0:	87 be       	out	0x37, r8	; 55
    7ed2:	e8 95       	spm
    7ed4:	c2 e0       	ldi	r28, 0x02	; 2
    7ed6:	d1 e0       	ldi	r29, 0x01	; 1
#endif
      
      // While that is going on, read in page contents
      bufPtr = buff;
      do *bufPtr++ = getch();
    7ed8:	5e d0       	rcall	.+188    	; 0x7f96 <getch>
    7eda:	89 93       	st	Y+, r24
      while (--length);
    7edc:	01 50       	subi	r16, 0x01	; 1
    7ede:	e1 f7       	brne	.-8      	; 0x7ed8 <main+0xd8>

      // If we are in NRWW section, page erase has to be delayed until now.
      // Todo: Take RAMPZ into account
#if !defined(NRWWSECTIONFAVORSIZE) 
      if (!((uint8_t)(address >> 8) < (uint8_t)(NRWWSTART >> 8)))
    7ee0:	10 37       	cpi	r17, 0x70	; 112
    7ee2:	18 f0       	brcs	.+6      	; 0x7eea <main+0xea>
#endif
        __boot_page_erase_short((uint16_t)(void*)address);
    7ee4:	f5 01       	movw	r30, r10
    7ee6:	87 be       	out	0x37, r8	; 55
    7ee8:	e8 95       	spm
      }
#endif

      // If only a partial page is to be programmed, the erase might not be complete.
      // So check that here
      boot_spm_busy_wait();
    7eea:	07 b6       	in	r0, 0x37	; 55
    7eec:	00 fc       	sbrc	r0, 0
    7eee:	fd cf       	rjmp	.-6      	; 0x7eea <main+0xea>
    7ef0:	a5 01       	movw	r20, r10
    7ef2:	a2 e0       	ldi	r26, 0x02	; 2
    7ef4:	b1 e0       	ldi	r27, 0x01	; 1
      bufPtr = buff;
      addrPtr = (uint16_t)(void*)address;
      ch = SPM_PAGESIZE / 2;
      do {
        uint16_t a;
        a = *bufPtr++;
    7ef6:	2c 91       	ld	r18, X
    7ef8:	30 e0       	ldi	r19, 0x00	; 0
        a |= (*bufPtr++) << 8;
    7efa:	11 96       	adiw	r26, 0x01	; 1
    7efc:	8c 91       	ld	r24, X
    7efe:	11 97       	sbiw	r26, 0x01	; 1
    7f00:	90 e0       	ldi	r25, 0x00	; 0
    7f02:	98 2f       	mov	r25, r24
    7f04:	88 27       	eor	r24, r24
    7f06:	82 2b       	or	r24, r18
    7f08:	93 2b       	or	r25, r19
register uint8_t timOverflCnt __asm__("r15"); // the number of timer1 overflows
#endif


/* main program starts here */
int main(void) {
    7f0a:	12 96       	adiw	r26, 0x02	; 2
      ch = SPM_PAGESIZE / 2;
      do {
        uint16_t a;
        a = *bufPtr++;
        a |= (*bufPtr++) << 8;
        __boot_page_fill_short((uint16_t)(void*)addrPtr,a);
    7f0c:	fa 01       	movw	r30, r20
    7f0e:	0c 01       	movw	r0, r24
    7f10:	67 be       	out	0x37, r6	; 55
    7f12:	e8 95       	spm
    7f14:	11 24       	eor	r1, r1
        addrPtr += 2;
    7f16:	4e 5f       	subi	r20, 0xFE	; 254
    7f18:	5f 4f       	sbci	r21, 0xFF	; 255
      } while (--ch);
    7f1a:	f1 e0       	ldi	r31, 0x01	; 1
    7f1c:	a2 38       	cpi	r26, 0x82	; 130
    7f1e:	bf 07       	cpc	r27, r31
    7f20:	51 f7       	brne	.-44     	; 0x7ef6 <main+0xf6>
      
      // Write from programming buffer
      __boot_page_write_short((uint16_t)(void*)address);
    7f22:	f5 01       	movw	r30, r10
    7f24:	57 be       	out	0x37, r5	; 55
    7f26:	e8 95       	spm
      boot_spm_busy_wait();
    7f28:	07 b6       	in	r0, 0x37	; 55
    7f2a:	00 fc       	sbrc	r0, 0
    7f2c:	fd cf       	rjmp	.-6      	; 0x7f28 <main+0x128>

#if defined(RWWSRE)
      // Reenable read access to flash
      boot_rww_enable();
    7f2e:	77 be       	out	0x37, r7	; 55
    7f30:	e8 95       	spm
    7f32:	25 c0       	rjmp	.+74     	; 0x7f7e <main+0x17e>

      // Read command terminator, start reply
      verifySpace();
    }
    /* Read memory block mode, length is big endian.  */
    else if(ch == STK_READ_PAGE) {
    7f34:	84 37       	cpi	r24, 0x74	; 116
    7f36:	b1 f4       	brne	.+44     	; 0x7f64 <main+0x164>
      // READ PAGE - we only read flash

      getch();			/* getlen */
    7f38:	2e d0       	rcall	.+92     	; 0x7f96 <getch>
      length = getch();
    7f3a:	2d d0       	rcall	.+90     	; 0x7f96 <getch>
    7f3c:	98 2e       	mov	r9, r24
      getch();
    7f3e:	2b d0       	rcall	.+86     	; 0x7f96 <getch>

      verifySpace();
    7f40:	4d d0       	rcall	.+154    	; 0x7fdc <verifySpace>
    7f42:	f5 01       	movw	r30, r10
    7f44:	c9 2c       	mov	r12, r9
        putch(result);
        address++;
      }
      while (--length);
#else
      do putch(pgm_read_byte_near(address++));
    7f46:	8f 01       	movw	r16, r30
    7f48:	0f 5f       	subi	r16, 0xFF	; 255
    7f4a:	1f 4f       	sbci	r17, 0xFF	; 255
    7f4c:	84 91       	lpm	r24, Z+
    7f4e:	1b d0       	rcall	.+54     	; 0x7f86 <putch>
      while (--length);
    7f50:	ca 94       	dec	r12
    7f52:	f8 01       	movw	r30, r16
    7f54:	c1 f7       	brne	.-16     	; 0x7f46 <main+0x146>
register uint8_t timOverflCnt __asm__("r15"); // the number of timer1 overflows
#endif


/* main program starts here */
int main(void) {
    7f56:	08 94       	sec
    7f58:	a1 1c       	adc	r10, r1
    7f5a:	b1 1c       	adc	r11, r1
    7f5c:	9a 94       	dec	r9
    7f5e:	a9 0c       	add	r10, r9
    7f60:	b1 1c       	adc	r11, r1
    7f62:	0e c0       	rjmp	.+28     	; 0x7f80 <main+0x180>
#endif
#endif
    }

    /* Get device signature bytes  */
    else if(ch == STK_READ_SIGN) {
    7f64:	85 37       	cpi	r24, 0x75	; 117
    7f66:	39 f4       	brne	.+14     	; 0x7f76 <main+0x176>
      // READ SIGN - return what Avrdude wants to hear
      verifySpace();
    7f68:	39 d0       	rcall	.+114    	; 0x7fdc <verifySpace>
      putch(SIGNATURE_0);
    7f6a:	8e e1       	ldi	r24, 0x1E	; 30
    7f6c:	0c d0       	rcall	.+24     	; 0x7f86 <putch>
      putch(SIGNATURE_1);
    7f6e:	85 e9       	ldi	r24, 0x95	; 149
    7f70:	0a d0       	rcall	.+20     	; 0x7f86 <putch>
      putch(SIGNATURE_2);
    7f72:	8f e0       	ldi	r24, 0x0F	; 15
    7f74:	9e cf       	rjmp	.-196    	; 0x7eb2 <main+0xb2>
    }
    else if (ch == 'Q') {
    7f76:	81 35       	cpi	r24, 0x51	; 81
    7f78:	11 f4       	brne	.+4      	; 0x7f7e <main+0x17e>
      // Adaboot no-wait mod
      watchdogConfig(WATCHDOG_16MS);
    7f7a:	88 e0       	ldi	r24, 0x08	; 8
    7f7c:	22 d0       	rcall	.+68     	; 0x7fc2 <watchdogConfig>
      verifySpace();
    }
    else {
      // This covers the response to commands like STK_ENTER_PROGMODE
      verifySpace();
    7f7e:	2e d0       	rcall	.+92     	; 0x7fdc <verifySpace>
    }
    putch(STK_OK);
    7f80:	80 e1       	ldi	r24, 0x10	; 16
    7f82:	01 d0       	rcall	.+2      	; 0x7f86 <putch>
    7f84:	6d cf       	rjmp	.-294    	; 0x7e60 <main+0x60>

00007f86 <putch>:
  }
}

void putch(char ch) {
    7f86:	98 2f       	mov	r25, r24
#ifndef SOFT_UART
  while (!(UCSR0A & _BV(UDRE0)));
    7f88:	80 91 c0 00 	lds	r24, 0x00C0
    7f8c:	85 ff       	sbrs	r24, 5
    7f8e:	fc cf       	rjmp	.-8      	; 0x7f88 <putch+0x2>
  UDR0 = ch;
    7f90:	90 93 c6 00 	sts	0x00C6, r25
      [uartBit] "I" (UART_TX_BIT)
    :
      "r25"
  );
#endif
}
    7f94:	08 95       	ret

00007f96 <getch>:
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
    7f96:	a8 95       	wdr
#if defined(BLUECONTROLLER) 
/* the watchdog time after startup is too small when the reset button has to be pressed manually
before starting the download. Additionally it takes some time to establish the bluetooth connection
and the Arduino IDE compiles the sketch before download. */
void extendWatchdogPeriodAfterStartup() {
  if(!blueCBtnNotPressed && timOverflCnt < (F_CPU/(1024*65536/EXTENDED_WAITTIME)))
    7f98:	2e 2d       	mov	r18, r14
    7f9a:	9f 2d       	mov	r25, r15
  {
    // each timer overflow takes 8.39 seconds @8MHz
    if(TIFR1 & _BV(TOV1))
    {
      TIFR1 = _BV(TOV1);
    7f9c:	31 e0       	ldi	r19, 0x01	; 1
    7f9e:	09 c0       	rjmp	.+18     	; 0x7fb2 <getch+0x1c>
#if defined(BLUECONTROLLER) 
/* the watchdog time after startup is too small when the reset button has to be pressed manually
before starting the download. Additionally it takes some time to establish the bluetooth connection
and the Arduino IDE compiles the sketch before download. */
void extendWatchdogPeriodAfterStartup() {
  if(!blueCBtnNotPressed && timOverflCnt < (F_CPU/(1024*65536/EXTENDED_WAITTIME)))
    7fa0:	22 23       	and	r18, r18
    7fa2:	39 f4       	brne	.+14     	; 0x7fb2 <getch+0x1c>
    7fa4:	94 30       	cpi	r25, 0x04	; 4
    7fa6:	28 f4       	brcc	.+10     	; 0x7fb2 <getch+0x1c>
  {
    // each timer overflow takes 8.39 seconds @8MHz
    if(TIFR1 & _BV(TOV1))
    7fa8:	b0 9b       	sbis	0x16, 0	; 22
    7faa:	02 c0       	rjmp	.+4      	; 0x7fb0 <getch+0x1a>
    {
      TIFR1 = _BV(TOV1);
    7fac:	36 bb       	out	0x16, r19	; 22
      timOverflCnt++;
    7fae:	9f 5f       	subi	r25, 0xFF	; 255
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
    7fb0:	a8 95       	wdr
      [uartBit] "I" (UART_RX_BIT)
    :
      "r25"
);
#else
  while(!(UCSR0A & _BV(RXC0)))
    7fb2:	80 91 c0 00 	lds	r24, 0x00C0
    7fb6:	87 ff       	sbrs	r24, 7
    7fb8:	f3 cf       	rjmp	.-26     	; 0x7fa0 <getch+0xa>
    7fba:	f9 2e       	mov	r15, r25
#if defined(BLUECONTROLLER) 
    extendWatchdogPeriodAfterStartup();
#endif
  }

  ch = UDR0;
    7fbc:	80 91 c6 00 	lds	r24, 0x00C6
  LED_PIN |= _BV(LED);
#endif
#endif

  return ch;
}
    7fc0:	08 95       	ret

00007fc2 <watchdogConfig>:
    "wdr\n"
  );
}

void watchdogConfig(uint8_t x) {
  WDTCSR = _BV(WDCE) | _BV(WDE);
    7fc2:	e0 e6       	ldi	r30, 0x60	; 96
    7fc4:	f0 e0       	ldi	r31, 0x00	; 0
    7fc6:	98 e1       	ldi	r25, 0x18	; 24
    7fc8:	90 83       	st	Z, r25
  WDTCSR = x;
    7fca:	80 83       	st	Z, r24
}
    7fcc:	08 95       	ret

00007fce <appStart>:
  }
}
#endif

void appStart() {
  LED_DDR |= _BV(LED); // switch LED to output
    7fce:	26 9a       	sbi	0x04, 6	; 4
  LED_PORT &= ~_BV(LED); // switch LED off
    7fd0:	2e 98       	cbi	0x05, 6	; 5
  watchdogConfig(WATCHDOG_OFF);
    7fd2:	80 e0       	ldi	r24, 0x00	; 0
    7fd4:	f6 df       	rcall	.-20     	; 0x7fc2 <watchdogConfig>
  __asm__ __volatile__ (
    7fd6:	ee 27       	eor	r30, r30
    7fd8:	ff 27       	eor	r31, r31
    7fda:	09 94       	ijmp

00007fdc <verifySpace>:
  do getch(); while (--count);
  verifySpace();
}

void verifySpace() {
  if (getch() == CRC_EOP)
    7fdc:	dc df       	rcall	.-72     	; 0x7f96 <getch>
    7fde:	80 32       	cpi	r24, 0x20	; 32
    7fe0:	11 f4       	brne	.+4      	; 0x7fe6 <verifySpace+0xa>
  {
    putch(STK_INSYNC);
    7fe2:	84 e1       	ldi	r24, 0x14	; 20
    7fe4:	d0 cf       	rjmp	.-96     	; 0x7f86 <putch>
  }
  else
  {
#if defined(BLUECONTROLLER) 
    // ignore error when not synced, otherwise some initial garbage will exit the bootloader
    if(blueCAvrdudeSynced)
    7fe6:	d1 10       	cpse	r13, r1
      appStart();
    7fe8:	f2 cf       	rjmp	.-28     	; 0x7fce <appStart>
    7fea:	08 95       	ret

00007fec <getNch>:
    ::[count] "M" (UART_B_VALUE)
  );
}
#endif

void getNch(uint8_t count) {
    7fec:	1f 93       	push	r17
    7fee:	18 2f       	mov	r17, r24
  do getch(); while (--count);
    7ff0:	d2 df       	rcall	.-92     	; 0x7f96 <getch>
    7ff2:	11 50       	subi	r17, 0x01	; 1
    7ff4:	e9 f7       	brne	.-6      	; 0x7ff0 <getNch+0x4>
  verifySpace();
    7ff6:	f2 df       	rcall	.-28     	; 0x7fdc <verifySpace>
}
    7ff8:	1f 91       	pop	r17
    7ffa:	08 95       	ret
